import { spawn } from 'child_process';
import { resolve, dirname } from 'path';
import { readFileSync, mkdirSync, writeFileSync, unlinkSync, linkSync as _linkSync } from 'fs';

function installArchSpecificPackage(version, require) {

  process.env.npm_config_global = 'false';

  var platform = process.platform == 'win32' ? 'win' : process.platform;
  var arch = platform == 'win' && process.arch == 'ia32' ? 'x86' : process.arch;

  var cp = spawn(platform == 'win' ? 'npm.cmd' : 'npm', ['install', '--no-save', ['node', platform, arch].join('-') + '@' + version], {
    stdio: 'inherit',
    shell: true
  });

  cp.on('close', function(code) {
    var pkgJson = require.resolve(['node', platform, arch].join('-') + '/package.json');
    var subpkg = JSON.parse(readFileSync(pkgJson, 'utf8'));
    var executable = subpkg.bin.node;
    var bin = resolve(dirname(pkgJson), executable);

    try {
      mkdirSync(resolve(process.cwd(), 'bin'));
    } catch (e) {
      if (e.code != 'EEXIST') {
        throw e;
      }
    }

    linkSync(bin, resolve(process.cwd(), executable));

    if (platform == 'win') {
      var pkg = JSON.parse(readFileSync(resolve(process.cwd(), 'package.json')));
      writeFileSync(resolve(process.cwd(), 'bin/node'), 'This file intentionally left blank');
      pkg.bin.node = 'bin/node.exe';
      writeFileSync(resolve(process.cwd(), 'package.json'), JSON.stringify(pkg, null, 2));
    }

    return process.exit(code);

  });
}

function linkSync(src, dest) {
  try {
    unlinkSync(dest);
  } catch (e) {
    if (e.code != 'ENOENT') {
      throw e;
    }
  }
  return _linkSync(src, dest);
}

export default installArchSpecificPackage;
